<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Model - VFF-Nav</title>
    <link rel="stylesheet" href="styles/main.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <nav class="navbar">
        <div class="container">
            <div class="nav-container">
                <a href="index.html" class="logo">VFF-Nav</a>
                <button class="nav-toggle">☰</button>
                <ul class="nav-menu">
                    <li><a href="index.html" class="nav-link">Home</a></li>
                    <li><a href="overview.html" class="nav-link">Overview</a></li>
                    <li><a href="quickstart.html" class="nav-link">Quick Start</a></li>
                    <li><a href="model.html" class="nav-link active">Model</a></li>
                    <li><a href="results.html" class="nav-link">Results</a></li>
                    <li><a href="team.html" class="nav-link">Team</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>Mathematical Model</h1>
            <p class="subtitle">Center of Mass Guidance Model - Electrostatic Analogy</p>
        </div>
    </header>

    <main class="container">
        <section>
            <h2>Model Overview</h2>
            <p>This model uses an analogy to electrostatic forces to guide a drone towards a goal while avoiding
                obstacles. The drone is treated as a charged particle influenced by attractive and repulsive forces.</p>
        </section>

        <section>
            <h2>Definitions</h2>
            <ul>
                <li>\(d\vec{p}\): Position vector of the drone</li>
                <li>\(d\vec{v} = \dfrac{d\vec{p}}{dt}\): Velocity vector of the drone</li>
                <li>\(\vec{g}\): Position vector of the goal</li>
                <li>\(\vec{o_i}\): Position vector of the center of obstacle \(i\) (assumed spherical)</li>
                <li>\(n_{obs}\): Number of obstacles</li>
                <li>\(\vec{r}_g = \vec{p} - \vec{g}\) (goal to drone)</li>
                <li>\(\vec{r}_i = \vec{p} - \vec{o_i}\) (obstacle to drone)</li>
                <li>\(\forall \vec{v} \neq \vec{0}, \hat{v} = \dfrac{\vec{v}}{\lVert\vec{v}\rVert}\). \(\hat{0} =
                    \vec{0}\). \(\hat{v}\) is dimensionless, even if \(\vec{v}\) has units.</li>
            </ul>
        </section>

        <section>
            <h2>Force Equations</h2>

            <h3>Total Force</h3>
            <div class="math-block">
                \[
                \vec{F}_{total} = \vec{F}_{goal} + \vec{F}_{\text{obs, squash}} + \vec{F}_{damping}
                \]
            </div>

            <h3>Goal Force</h3>
            <div class="math-block">
                \[
                \vec{F}_{goal} = \left( -F_{\text{goal, const}} + \frac{k_e \cdot Q_{drone} \cdot
                Q_{\text{goal}}}{\lVert\vec{r}_g\rVert^2 + \varepsilon_{\text{goal}}^2} \right) \hat{r}_g
                \]
            </div>

            <p><strong>Notes:</strong></p>
            <ul>
                <li>The goal force is always attractive, pulling the drone towards the goal, due to \(Q_{goal} <
                        0\).</li>
                <li>\(k_e = 1 \left(N \cdot m^2 \cdot C^{-2}\right)\), a Coulomb's constant analog, is included for
                    dimensional consistency.</li>
                <li>\(Q_{drone} = 1 \left(C\right)\) is the drone's charge, which is constant.</li>
            </ul>

            <h3>Obstacle Force</h3>
            <div class="math-block">
                \[
                \vec{F}_{\text{obs},i} = \left( \frac{ k_e \cdot Q_{drone} \cdot Q_i }{ \lVert\vec{r}_i\rVert^2 +
                \varepsilon_{\text{obs}}^2 } \right) \hat{r}_i
                \]
            </div>

            <h4>Raw and Squashed Obstacle Force</h4>
            <div class="math-block">
                \[
                \vec{F}_{\text{obs, raw}} = \sum_{i=1}^{n_{\text{obs}}}{\vec{F}_{\text{obs},i}}
                \]
                \[
                \vec{F}_{\text{obs, squash}} = F_{\text{fac,squash}} \cdot \tanh\left( \frac{ \lVert \vec{F}_{\text{obs,
                raw}} \rVert }{ F_{\text{sat}} } \right) \cdot \hat{F}_{\text{obs, raw}}
                \]
            </div>

            <h3>Damping Force</h3>
            <div class="math-block">
                \[
                \vec{F}_{damping} = -K_{damping} \cdot \vec{v}
                \]
            </div>

            <h3>From Guidance Field to Desired Velocity</h3>
            <p>Let \(\vec{F}_{\text{field}}\) define the direction in which the drone "should" move:</p>

            <p><strong>Compute the unit direction:</strong></p>
            <div class="math-block">
                \[
                \hat{d} = \begin{cases}
                \dfrac{\vec{F}_{\text{field}}}{\Vert \vec{F}_{\text{field}} \Vert}, & \text{if } \vec{F}_{\text{field}}
                \neq \vec{0} \\
                \vec{0}, & \text{otherwise}
                \end{cases}
                \]
            </div>

            <p>Fix a target scalar speed \(v_{\text{ideal}} > 0\) (constant in the code).</p>

            <p><strong>Define the desired velocity vector:</strong></p>
            <div class="math-block">
                \[
                \vec{v}_{\text{set}} = v_{\text{ideal}} \cdot \hat{d}
                \]
            </div>

            <p>So the electrostatic part now answers: "Which direction should I go, if I want to fly at speed
                \(v_{\text{ideal}}\)?" and no longer directly dictates the force.</p>

            <h3>Velocity Tracking with Vector PID</h3>
            <p>A 3D PID controller tracks \(\vec{v}_{\text{set}}\) by adjusting the force applied to the drone.</p>

            <p><strong>PID structure:</strong></p>
            <p>You have a scalar PID:</p>
            <ul>
                <li>Input: scalar setpoint, scalar measurement, time step \(dt\)</li>
                <li>Output: scalar control effort (interpreted as force in that axis)</li>
            </ul>

            <p>and a vector wrapper (PidVectorIsomorphic) that applies this PID independently to \(x\), \(y\) and \(z\)
                components:</p>
            <div class="math-block">
                \[
                \vec{F}_{\text{PID}} = \begin{bmatrix} u_x \\ u_y \\ u_z \end{bmatrix} = \begin{bmatrix}
                \text{PID}_x(v_{\text{set},x}, v_x, dt) \\ \text{PID}_y(v_{\text{set},y}, v_y, dt) \\
                \text{PID}_z(v_{\text{set},z}, v_z, dt) \end{bmatrix}
                \]
            </div>

            <p><strong>Given:</strong></p>
            <ul>
                <li>Setpoint: \(\vec{v}_{\text{set}}\)</li>
                <li>Measurement: current velocity \(\vec{v}\)</li>
                <li>Output: control force \(\vec{F}_{\text{PID}}\)</li>
            </ul>

            <p>Since the drone mass is fixed at \(m_{\text{drone}} = 1 \, \text{kg}\), the dynamics are:</p>
            <div class="math-block">
                \[
                \vec{a} = \frac{\vec{F}_{\text{PID}}}{m_{\text{drone}}} = \vec{F}_{\text{PID}}
                \]
            </div>

            <p>So PID output has units of Newtons and is exactly the net force applied to the drone in the simulation.
            </p>

            <p><strong>Gains and dependency:</strong></p>
            <p>The proportional gain \(k_P\) is fixed at \(1\). \(k_I\) and \(k_D\) become parameters to be tuned by the
                calibration system.</p>
            <p>Fixing \(k_P = 1\) is a way to avoid a useless extra degree of freedom: the overall scaling of the
                feedback force can already be controlled through other parameters (e.g., \(v_{\text{ideal}}\), squashing
                factors, charges). If you allowed \(k_P\) to float freely and also scaled the field / speeds, you'd
                introduce a linear dependency where multiple parameter combinations produce essentially the same
                behavior.</p>
        </section>

        <section>
            <h2>System Invariants</h2>
            <ul>
                <li>Coulomb's constant (analog): \(k_e = 1 \left(N \cdot m^2 \cdot C^{-2}\right)\)</li>
                <li>Drone mass: \(m_{drone} = 1 \left(kg\right)\)</li>
                <li>Drone charge: \(Q_{drone} = 1 \left(C\right)\)</li>
                <li>Obstacle charges: \(Q_i \in [0, +1] \left(C\right)\)</li>
                <li>Ideal velocity: \(v_{\text{ideal}}\) = 5.0 \left(m.s\right)</li>
            </ul>
        </section>

        <section>
            <h2>Parameters for Calibration</h2>
            <p>These parameters are determined by the simulation calibration program.</p>

            <table>
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Description</th>
                        <th>Unit</th>
                        <th>Range</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>\(Q_{goal}\)</td>
                        <td>Goal charge</td>
                        <td>C</td>
                        <td>\(]-\infty, 0[\)</td>
                    </tr>
                    <tr>
                        <td>\(F_{goal, const}\)</td>
                        <td>Goal constant attraction</td>
                        <td>N</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(\varepsilon_{goal}\)</td>
                        <td>Goal softening factor</td>
                        <td>m</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(\varepsilon_{obs}\)</td>
                        <td>Obstacle softening factor</td>
                        <td>m</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(F_{\text{sat}}\)</td>
                        <td>Obstacle total saturation scale</td>
                        <td>N</td>
                        <td>\(]0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(F_{\text{fac,squash}}\)</td>
                        <td>Obstacle total factor after squashing</td>
                        <td>N</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(K_{damping}\)</td>
                        <td>Damping constant</td>
                        <td>N·s/m</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(k_I\)</td>
                        <td>Integral gain</td>
                        <td>-</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                    <tr>
                        <td>\(k_D\)</td>
                        <td>Derivative gain</td>
                        <td>-</td>
                        <td>\([0, +\infty[\)</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>Implementation Notes</h2>
            <ul>
                <li><strong>No singularities:</strong> Both goal and obstacles use \(\varepsilon\) to avoid \(1/r^2\)
                    blow-ups.</li>
                <li><strong>Dimensionless tanh:</strong> \(\dfrac{\lVert \vec{F}_{\text{obs, raw}}
                    \rVert}{F_{\text{sat}}}\) is unitless; \(F_{\text{fac,squash}}\) carries the resulting Newton scale.
                </li>
                <li><strong>Performance optimization:</strong> For \(\lvert \tanh(x) - x \rvert < 0.01\) when \(x \in
                        [-0.3, 0.3]\), we skip squashing to improve performance.</li>
                <li><strong>Velocity control:</strong> The system uses a two-stage approach: electrostatic field for
                    direction guidance and PID control for velocity tracking.</li>
            </ul>
        </section>

        <div class="navigation-buttons">
            <a href="quickstart.html" class="btn">← Quick Start</a>
            <a href="results.html" class="btn">Results →</a>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>Developed at Escola Politécnica da USP</p>
            <p>Department of Computer Engineering and Digital Systems</p>
        </div>
    </footer>

    <script src="scripts/main.js"></script>
</body>

</html>